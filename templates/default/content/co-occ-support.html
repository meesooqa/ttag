{{define "content"}}
<style>
    .cell {stroke: #ccc;}
    .label { font-size: 12px; fill: #333; }

    /*.node { stroke: #fff; stroke-width: 1.5px; }*/
    /*.link { stroke: #999; stroke-opacity: 0.6; }*/

    .link { fill: none; stroke: steelblue; stroke-opacity: 0.6; }
    .node { fill: #ff8c00; }

</style>
<!--<h3>Тепловая карта поддержки (Support)</h3>-->
<!--<svg id="heatmap" width="2000" height="2000"></svg>-->
<!--<h3>Сетевой граф для Support (Force-Directed Graph)</h3>-->
<!--<svg id="fdgraph" width="1000" height="1000"></svg>-->
<h3>Arc Diagram для Support</h3>
<svg id="arc" width="8000" height="2000"></svg>
<script>
    function buildApiUrl(base) {
        const url = new URL(base, window.location.href);
        const params = new URLSearchParams(window.location.search);
        params.forEach((v, k) => url.searchParams.set(k, v));
        return url;
    }
document.addEventListener('DOMContentLoaded', function() {
    d3.json(buildApiUrl('/api/coocc_support_d3.json')).then(function(data) {
        const svg = d3.select("svg#heatmap");
        if (!svg) {
            return;
        }

        // Извлекаем список уникальных тегов
        const tags = Array.from(new Set(data.pairs.flatMap(d => [d.tagA, d.tagB]))).sort();

        // Создаем объект-матрицу для хранения значений support
        const matrix = {};
        tags.forEach(tag => matrix[tag] = {});
        data.pairs.forEach(d => {
            matrix[d.tagA][d.tagB] = d.support;
            matrix[d.tagB][d.tagA] = d.support; // симметрично
        });

        // const cellSize = 20;
        // const offset = 100;
        const cellSize = 10;
        const offset = 50;

        // Определяем шкалу цвета для значений support от 0 до максимального (обычно не более 1)
        const maxSupport = d3.max(data.pairs, d => d.support);
        const colorScale = d3.scaleSequential(d3.interpolateBlues)
            .domain([0, maxSupport]);

        // Рисуем ячейки матрицы
        tags.forEach((tagA, i) => {
            tags.forEach((tagB, j) => {
                const value = matrix[tagA][tagB] || 0;
                svg.append("rect")
                    .attr("x", i * cellSize + offset)
                    .attr("y", j * cellSize + offset)
                    .attr("width", cellSize)
                    .attr("height", cellSize)
                    .attr("fill", colorScale(value))
                    .attr("class", "cell")
                    .append("title")
                    .text(`(${tagA}, ${tagB}): ${value.toFixed(2)}`);
            });
        });

        // Подписи для осей Y (слева)
        tags.forEach((tag, j) => {
            svg.append("text")
                .attr("x", offset - 10)
                .attr("y", j * cellSize + offset + cellSize / 2)
                .attr("dy", ".35em")
                .attr("text-anchor", "end")
                .attr("class", "label")
                .text(tag);
        });

        // Подписи для осей X (сверху)
        tags.forEach((tag, i) => {
            svg.append("text")
                .attr("x", i * cellSize + offset + cellSize / 2)
                .attr("y", offset - 10)
                .attr("dy", ".35em")
                .attr("text-anchor", "middle")
                .attr("class", "label")
                .text(tag);
        });
    }).catch(function(error) {
        console.error("Ошибка загрузки данных:", error);
    });

    d3.json(buildApiUrl('/api/coocc_support_d3.json')).then(function(data) {
        const svg = d3.select("svg#fdgraph");
        if (!svg) {
            return;
        }

        // Формирование списка уникальных тегов
        const nodes = {};
        data.pairs.forEach(pair => {
            nodes[pair.tagA] = { id: pair.tagA };
            nodes[pair.tagB] = { id: pair.tagB };
        });
        const nodesArray = Object.values(nodes);

        // Формирование массива связей с использованием support
        const linksArray = data.pairs.map(pair => ({
            source: pair.tagA,
            target: pair.tagB,
            support: pair.support
        }));

        const width = +svg.attr("width"),
            height = +svg.attr("height");

        // Создаем силовую симуляцию
        const simulation = d3.forceSimulation(nodesArray)
            .force("link", d3.forceLink(linksArray).id(d => d.id).distance(150))
            .force("charge", d3.forceManyBody().strength(-200))
            .force("center", d3.forceCenter(width / 2, height / 2));

        // Отрисовка связей
        const link = svg.append("g")
            .attr("class", "links")
            .selectAll("line")
            .data(linksArray)
            .enter().append("line")
            .attr("class", "link")
            .style("stroke-width", d => d.support * 10); // Настройте коэффициент по необходимости

        // Отрисовка узлов
        const node = svg.append("g")
            .attr("class", "nodes")
            .selectAll("circle")
            .data(nodesArray)
            .enter().append("circle")
            .attr("class", "node")
            .attr("r", 8)
            .attr("fill", d => d3.schemeCategory10[d.id.charCodeAt(0) % 10])
            .call(drag(simulation));

        // Подписи для узлов
        const label = svg.append("g")
            .attr("class", "labels")
            .selectAll("text")
            .data(nodesArray)
            .enter().append("text")
            .attr("dy", -10)
            .text(d => d.id);

        simulation.on("tick", () => {
            link.attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);

            node.attr("cx", d => d.x)
                .attr("cy", d => d.y);

            label.attr("x", d => d.x)
                .attr("y", d => d.y);
        });

        // Функция для перетаскивания узлов
        function drag(simulation) {
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }
            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }
            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
            return d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended);
        }
    }).catch(function(error) {
        console.error("Ошибка загрузки данных:", error);
    });

    d3.json(buildApiUrl('/api/coocc_support_d3.json')).then(function(data) {
        const svg = d3.select("svg#arc");
        if (!svg) {
            return;
        }

        // Извлечение уникальных тегов и сортировка
        const tags = Array.from(new Set(data.pairs.flatMap(d => [d.tagA, d.tagB]))).sort();
        const width = +svg.attr("width");
        const margin = {left: 50, right: 50};

        // Создаем шкалу для расположения тегов вдоль горизонтальной оси
        const xScale = d3.scalePoint()
            .domain(tags)
            .range([margin.left, width - margin.right]);

        // Отрисовка узлов (кругов) вдоль базовой линии
        svg.selectAll("circle")
            .data(tags)
            .enter().append("circle")
            .attr("cx", d => xScale(d))
            .attr("cy", 150)
            .attr("r", 5)
            .attr("class", "node");

        // Подписи для тегов
        svg.selectAll("text")
            .data(tags)
            .enter().append("text")
            .attr("x", d => xScale(d))
            .attr("y", 170)
            .attr("text-anchor", "middle")
            .attr("class", "label")
            .text(d => d);

        // Отрисовка дуг для каждой пары тегов
        data.pairs.forEach(pair => {
            const x1 = xScale(pair.tagA);
            const x2 = xScale(pair.tagB);
            const support = pair.support;
            const arcPath = d3.path();
            // Рассчитываем радиус дуги в зависимости от расстояния между тегами
            const dx = x2 - x1;
            const dr = Math.abs(dx) / 2;
            arcPath.moveTo(x1, 150);
            arcPath.arcTo((x1 + x2) / 2, 150 - dr, x2, 150, dr);
            svg.append("path")
                .attr("d", arcPath.toString())
                .attr("class", "link")
                .style("stroke-width", support * 10) // Коэффициент для наглядности
                .append("title")
                .text(`${pair.tagA} - ${pair.tagB}: ${support.toFixed(2)}`);
        });
    }).catch(function(error) {
        console.error("Ошибка загрузки данных:", error);
    });
});
</script>
{{end}}
