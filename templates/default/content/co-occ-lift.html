{{define "content"}}
<style>
    body {
        font-family: Arial, sans-serif;
    }
    svg {
        border: 1px solid #ccc;
    }
    .node {
        stroke: #fff;
        stroke-width: 1.5px;
    }
    .link {
        stroke: #999;
        stroke-opacity: 0.6;
    }
    .labels {
        font-size: 12px;
        fill: #333;
    }

    .cell { stroke: #ccc; }

    .node {
        stroke: #fff;
        stroke-width: 1.5px;
    }
    .label {
        font-family: sans-serif;
        text-anchor: middle;
        fill: #333;
        pointer-events: none;
    }
</style>
<h3>Граф взаимосвязей тегов: метрика Lift</h3>
<svg id="graph" width="1200" height="1200"></svg>
<h3>Chord Diagram (диаграмма хорд)</h3>
<svg id="chord" width="1200" height="1200"></svg>
<h3>Bubble Chart (пузырьковая диаграмма)</h3>
<svg id="bubble" width="1000" height="1000"></svg>

<script>
function buildApiUrl(base) {
    const url = new URL(base, window.location.href);
    const params = new URLSearchParams(window.location.search);
    params.forEach((v, k) => url.searchParams.set(k, v));
    return url;
}

document.addEventListener('DOMContentLoaded', function() {
    d3.json(buildApiUrl('/api/coocc_lift_d3.json')).then(function(data) {
        // data предполагается в формате:
        // { pairs: [{ tagA: "тег1", tagB: "тег2", lift: значение }, ...] }

        const svg = d3.select("svg#graph");
        if (!svg) {
            return;
        }

        // Создание множества узлов из пар тегов
        const nodes = {};
        data.pairs.forEach(pair => {
            nodes[pair.tagA] = { id: pair.tagA };
            nodes[pair.tagB] = { id: pair.tagB };
        });
        const nodesArray = Object.values(nodes);

        // Формирование массива связей
        const linksArray = data.pairs.map(pair => ({
            source: pair.tagA,
            target: pair.tagB,
            lift: pair.lift
        }));

        // Настройка размеров svg
        const width = +svg.attr("width"),
            height = +svg.attr("height");

        // Создание силовой симуляции
        const simulation = d3.forceSimulation(nodesArray)
            .force("link", d3.forceLink(linksArray).id(d => d.id).distance(d => 200 / d.lift))
            .force("charge", d3.forceManyBody().strength(-200))
            .force("center", d3.forceCenter(width / 2, height / 2));

        // Отрисовка связей
        const link = svg.append("g")
            .attr("class", "links")
            .selectAll("line")
            .data(linksArray)
            .enter().append("line")
            .attr("class", "link")
            .style("stroke-width", d => Math.sqrt(d.lift));

        // Отрисовка узлов
        const node = svg.append("g")
            .attr("class", "nodes")
            .selectAll("circle")
            .data(nodesArray)
            .enter().append("circle")
            .attr("class", "node")
            .attr("r", 8)
            .call(drag(simulation));

        // Добавление подписей к узлам
        const label = svg.append("g")
            .attr("class", "labels")
            .selectAll("text")
            .data(nodesArray)
            .enter().append("text")
            .attr("dy", -10)
            .text(d => d.id);

        // Обновление позиций при каждом тике симуляции
        simulation.on("tick", () => {
            link
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);

            node
                .attr("cx", d => d.x)
                .attr("cy", d => d.y);

            label
                .attr("x", d => d.x)
                .attr("y", d => d.y);
        });

        // Функции для реализации перетаскивания узлов
        function drag(simulation) {
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }
            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }
            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
            return d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended);
        }
    }).catch(function(error) {
        console.error("Ошибка загрузки данных:", error);
    });

    d3.json(buildApiUrl('/api/coocc_lift_d3.json')).then(function(data) {
        const svg = d3.select("svg#chord");
        if (!svg) {
            return;
        }

        const tags = Array.from(new Set(data.pairs.flatMap(d => [d.tagA, d.tagB])));
        const index = new Map(tags.map((tag, i) => [tag, i]));
        const matrix = Array.from({ length: tags.length }, () => new Array(tags.length).fill(0));

        data.pairs.forEach(d => {
            matrix[index.get(d.tagA)][index.get(d.tagB)] = d.lift;
            matrix[index.get(d.tagB)][index.get(d.tagA)] = d.lift;
        });

        const width = +svg.attr("width"),
            height = +svg.attr("height"),
            outerRadius = Math.min(width, height) * 0.4,
            innerRadius = outerRadius - 30;

        const chord = d3.chord().padAngle(0.05)(matrix);
        const arc = d3.arc().innerRadius(innerRadius).outerRadius(outerRadius);
        const ribbon = d3.ribbon().radius(innerRadius);

        const g = svg.append("g").attr("transform", `translate(${width / 2},${height / 2})`);

        g.append("g").selectAll("path")
            .data(chord.groups)
            .enter().append("path")
            .attr("fill", d => d3.schemeCategory10[d.index % 10])
            .attr("stroke", "#000")
            .attr("d", arc);

        g.append("g").selectAll("path")
            .data(chord)
            .enter().append("path")
            .attr("d", ribbon)
            .attr("fill", d => d3.schemeCategory10[d.target.index % 10])
            .attr("stroke", "#000");

        g.append("g").selectAll("text")
            .data(chord.groups)
            .enter().append("text")
            .attr("dy", ".35em")
            .attr("transform", d => `rotate(${(d.startAngle + d.endAngle) / 2 * 180 / Math.PI - 90}) translate(${outerRadius + 10})`)
            .text(d => tags[d.index])
            .style("font-size", "12px");
    });

    d3.json(buildApiUrl('/api/coocc_lift_d3.json')).then(function(data) {
        const svg = d3.select("svg#bubble");
        if (!svg) {
            return;
        }

        const nodes = Object.entries(data.tagFreq).map(([tag, frequency]) => ({
            id: tag,
            frequency: frequency
        }));

        const width = +svg.attr("width"),
            height = +svg.attr("height");

        // Преобразуем данные в иерархическую структуру.
        const root = d3.hierarchy({ children: nodes })
            .sum(d => d.frequency)
            .sort((a, b) => b.value - a.value);

        const pack = d3.pack()
            .size([width, height])
            .padding(5);

        pack(root);

        const node = svg.selectAll("g")
            .data(root.leaves())
            .enter().append("g")
            .attr("transform", d => `translate(${d.x},${d.y})`);

        node.append("circle")
            .attr("class", "node")
            .attr("r", d => d.r)
            .attr("fill", d => d3.schemeCategory10[d.data.id.charCodeAt(0) % 10]);

        node.append("text")
            .attr("class", "label")
            .attr("dy", "0.3em")
            .text(d => d.data.id)
            .style("font-size", d => Math.min(2 * d.r, (2 * d.r - 8) / d.data.id.length) + "px");
    }).catch(function(error) {
        console.error("Ошибка загрузки данных:", error);
    });
});
</script>
{{end}}
